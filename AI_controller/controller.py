# -*- coding: utf-8 -*-
import numpy
import math
import random
from .state import State
import random
import datetime, time
import operator

def normalize(value, oldmin, oldmax, newmin, newmax):
    newvalue = (((float(value) - oldmin) * (newmax - newmin)) / (oldmax - oldmin)) + newmin
    return newvalue

class Controller:
    def __init__(self, game, load, state):
        self.initialize_parameters(game, load, state)
        self.last_parameters = self.parameters
        self.last_performance = 0
        self.ithundred = 0
        self.itparents = 0
        self.last_hundred = {}
        self.ten_parents = {}
        self.next_hundred = []
        self.next_parents = []
        self.keys = []
        self.parents_keys = []
        #self.maxvely = 0

    def initialize_parameters(self, game, load,state):
        self.state = state
        if load == None:
            self.parameters = numpy.random.normal(0, 1, 3*len(self.compute_features()))
        else:
            params = open(load, 'r')
            weights = params.read().split("\n")
            self.parameters = [float(x.strip()) for x in weights[0:-1]]


    def output(self, episode, performance):
       print "Performance do episodio #%d: %d" % (episode, performance)
       if episode > 10 and self.itparents == 11 and (episode-10) % 100 == 0:
           output = open("./params/%s.txt" % datetime.datetime.fromtimestamp(time.time()).strftime('%Y%m%d%H%M%S'), "w+")
           best_parameters = random.choice(self.parents_keys)
           for parameter in best_parameters:            
                output.write(str(parameter) + "\n")

#--------------------------------------------------------------------------------------------------------

    #FUNCAO A SER COMPLETADA. Deve utilizar os pesos para calcular as funções de preferência Q para cada ação e retorna
    #-1 caso a ação desejada seja esquerda, +1 caso seja direita, e 0 caso seja ação nula
    def take_action(self, state):
        self.state = state
        features = self.compute_features()
        parameters = self.parameters
	NFEATURES = len(self.compute_features())
        parameters_e = parameters[0:NFEATURES]
        parameters_n = parameters[NFEATURES:NFEATURES*2]
        parameters_d = parameters[NFEATURES*2:NFEATURES*3]

        e = numpy.dot(features,parameters_e)
        
        n = numpy.dot(features,parameters_n)
        
        d = numpy.dot(features,parameters_d)
        
        if d > e and d > n: #melhor = direita
            return 1
        elif e > n: #melhor = esquerda
            return -1
        else: #melhor = ficar parado
            return 0

##        if self.state.angular_velocity < self.maxvely:
##            self.maxvely = self.state.angular_velocity
##            print "Maior Velocidade Angular: " + str(self.state.angular_velocity)
##            
##        return 1 #sempre retornar direita (para ver limite de velocidade)

    #FUNCAO A SER COMPLETADA. Deve calcular features expandidas do estados (Dica: deve retornar um vetor)
    def compute_features(self):
        features = []

        x = self.state.wheel_x
        vel = self.state.angular_velocity
        ang = self.state.rod_angle
        wind = self.state.wind
        fric = self.state.friction
        vel_x = self.state.velocity_x
        vel_y = self.state.velocity_y

        x = normalize(x,0,1200,-1,1)
        vel = normalize(vel,-3600,3600,-1,1)     #empiricamente observado que vai de -3600 até 3600
        ang = normalize(ang,-60,60,-1,1)         #empiricamente observado que vai de -60 até 60
        wind = normalize(wind,-500,500,-1,1)
        fric = normalize(fric,0.970,0.999,-1,1)
        vel_x = normalize(vel_x,-1600,1600,-1,1) #empiricamente observado que vai de -1600 até 1600
        vel_y = normalize(vel_y,-250,1200,-1,1)  #empiricamente observado que vai de -250 até 1200

        features.append(x)
        features.append(vel)
        features.append(ang)
        features.append(wind)
        features.append(fric)
        features.append(vel_x)
        features.append(vel_y)
        features.append(vel_x + x)

        return features

        
    #FUNCAO A SER COMPLETADA. Deve atualizar a propriedade self.parameters
    def update(self, episode, performance):
        #LOCAL BEAM SEARCH
        if(self.itparents == 0):
            self.keys.append(self.parameters)
            self.ten_parents[self.itparents] = performance #save in parents hash
            for i in range(9): #generate other 9 parents (the 1st is the generated by initialize_parameters in __init__)
                self.next_parents.append(numpy.random.normal(0, 1, 3*len(self.compute_features())))
            self.parameters = self.next_parents[0] #pick first next parent
            self.itparents += 1;

        elif(self.itparents < 9): #processing first 9 parents
            self.keys.append(self.parameters)
            self.ten_parents[self.itparents] = performance #save in parents hash
            self.parameters = self.next_parents[self.itparents] #pick next parent
            self.itparents += 1;

        elif (self.itparents == 9): #end of processing first parents, generate first generation (each parent has 10 "children")
            self.keys.append(self.parameters)
            self.ten_parents[self.itparents] = performance #save in parents hash
            for parent in self.ten_parents.keys():
                parent_params = self.keys[parent]
                for i in range(10):
                    disturb = numpy.random.normal(0, 1, 3*len(self.compute_features()))
                    #disturb *= 0.1
                    self.next_hundred.append(parent_params+disturb) #append 10 disturbed version of each father
            self.itparents = 11 #to never enter in the first three if's again
            del self.keys[:]
            self.parameters = self.next_hundred[self.ithundred] #pick first child
            self.ithundred +=1;
            print "End of processing fathers, starting children processing..."

        elif (self.ithundred > 0 and (self.ithundred % 100) != 0): #processing 100 children
            self.keys.append(self.parameters)
            self.last_hundred[(self.ithundred%100)-1] = performance #save in children hash
            self.parameters = self.next_hundred[self.ithundred%100] #pick next child
            self.ithundred +=1;

        elif (self.ithundred > 0 and (self.ithundred % 100) == 0): #end of processing children, select Top 10 and generate next generation
            self.keys.append(self.parameters)
            self.last_hundred[(self.ithundred%100)-1] = performance #save in children hash
            self.ten_parents = dict(sorted(dict(self.last_hundred.items()).iteritems(),key=operator.itemgetter(1),reverse=True)[:10])#select 10 best children
            del self.next_hundred[:]
            for parent in self.ten_parents.keys():
                parent_params = self.keys[parent]
                self.parents_keys.append(parent_params) #for saving parameters
                for i in range(10):
                    disturb = numpy.random.normal(0, 1, 3*len(self.compute_features()))
                    #disturb *= 0.1
                    self.next_hundred.append(parent_params+disturb) #append 10 disturbed version of each father
            del self.keys[:]
            self.parameters = self.next_hundred[self.ithundred%100] #pick first child
            self.ithundred +=1;

        else:
            print "\n\n\n\nFAIL\n\n\n\n"
                    
            
        #SIMULATED ANNEALING
        #temperature = (10000/(episode+1))
        #if performance > self.last_performance: #se for melhor, salva o novo, senão, depende da probabilidade/temperatura
        #        self.last_parameters = self.parameters
        #        self.last_performance = performance
        #else:
        #    if temperature > 0:
        #        diff = performance - self.last_performance
        #        prob = math.e**(diff/temperature)
        #        if (round(random.uniform(0,1),5) <= prob): #será considerado, mesmo sendo pior; senão, não será atualizado
        #            self.last_parameters = self.parameters
        #            self.last_performance = performance
        #disturb = numpy.random.normal(0, 1, 3*len(self.compute_features()))
        #disturb *= 0.1
        #self.parameters += disturb
